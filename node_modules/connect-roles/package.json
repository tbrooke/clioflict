{
  "name": "connect-roles",
  "description": "Provides dynamic roles based authentication for node.js connect and express servers.",
  "version": "2.1.0",
  "homepage": "http://documentup.com/ForbesLindesay/connect-roles",
  "repository": {
    "type": "git",
    "url": "git://github.com/ForbesLindesay/connect-roles.git"
  },
  "main": "./index",
  "devDependencies": {
    "should": "*",
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "author": {
    "name": "Forbes Lindesay"
  },
  "license": "BSD",
  "keywords": [
    "roles",
    "authorization",
    "authentication",
    "security",
    "connect",
    "express",
    "passport",
    "everyauth"
  ],
  "dependencies": {
    "debug": "0.7.2",
    "path-to-regexp": "0.0.2"
  },
  "readme": "# Connect Roles\r\n<img src=\"http://i.imgur.com/opZKqAi.png\" align=\"right\"/>\r\n\r\n  Connect roles is designed to work with connect or express.  It is an authorisation provider, not an authentication provider.  It is designed to support context sensitive roles/abilities, through the use of middleware style authorisation strategies.\r\n\r\n  If you're looking for an authentication system I suggest you check out [passport.js](https://github.com/jaredhanson/passport)\r\n\r\n[![Build Status](https://secure.travis-ci.org/ForbesLindesay/connect-roles.png?branch=master)](http://travis-ci.org/ForbesLindesay/connect-roles)\r\n[![Dependency Status](https://gemnasium.com/ForbesLindesay/connect-roles.png)](https://gemnasium.com/ForbesLindesay/connect-roles)\r\n[![NPM version](https://badge.fury.io/js/connect-roles.png)](http://badge.fury.io/js/connect-roles)\r\n\r\n## Installation\r\n\r\n    $ npm install connect-roles\r\n\r\n## Usage\r\n\r\n```javascript\r\nvar authentication = require('your-authentication-module-here');\r\nvar user = require('connect-roles');\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.use(authentication)\r\napp.use(user);\r\n\r\n//anonymous users can only access the home page\r\n//returning false stops any more rules from being\r\n//considered\r\nuser.use(function (req, action) {\r\n  if (!req.user.isAuthenticated) return action === 'access home page';\r\n})\r\n\r\n//moderator users can access private page, but\r\n//they might not be the only one so we don't return\r\n//false if the user isn't a moderator\r\nuser.use('access private page', function (req) {\r\n  if (req.user.role ==== 'moderator') {\r\n    return true;\r\n  }\r\n})\r\n\r\n//admin users can access all pages\r\nuser.use(function (req) {\r\n  if (req.user.role === 'admin') {\r\n    return true;\r\n  }\r\n});\r\n\r\n//optionally controll the access denid page displayed\r\nuser.setFailureHandler(function (req, res, action){\r\n  var accept = req.headers.accept || '';\r\n  res.status(403);\r\n  if (~accept.indexOf('html')) {\r\n    res.render('access-denied', {action: action});\r\n  } else {\r\n    res.send('Access Denied - You don\\'t have permission to: ' + action);\r\n  }\r\n});\r\n\r\n\r\napp.get('/', user.can('access home page'), function (req, res) {\r\n  res.render('private');\r\n});\r\napp.get('/private', user.can('access private page'), function (req, res) {\r\n  res.render('private');\r\n});\r\napp.get('/admin', user.can('access admin page'), function (req, res) {\r\n  res.render('admin');\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n## API\r\n\r\n### roles.use(fn(req, action))\r\n\r\n  Define and authorisation strategy which takes the current request and the action being performed.  fn may return `true`, `false` or `undefined`/`null`\r\n\r\n  If `true` is returned then no further strategies are considred, and the user is **granted** access.\r\n\r\n  If `false` is returned, no further strategies are considered, and the user is **denied** access.\r\n\r\n  If `null`/`undefined` is returned, the next strategy is considerd.  If it is the last strategy then access is **denied**.\r\n\r\n### roles.use(action, fn(req))\r\n\r\n  The strategy `fn` is only used when the action is equal to `action`.  It has the same behaviour with regards to return values as `roles.use(fn(req, action))` (see above).\r\n\r\n  It is equivallent to calling:\r\n\r\n  ```javascript\r\n  roles.use(function (req, act) {\r\n    if (act === action) {\r\n      return fn(req);\r\n    }\r\n  });\r\n  ```\r\n\r\n  **N.B.** The action must not start with a `/` character or it will call `roles.use(path, fn(req, action))`\r\n\r\n### roles.use(action, path, fn(req))\r\n\r\n  Path must be an express style route.  It will then attach any parameters to `req.params`.\r\n\r\n  e.g.\r\n\r\n```javascript\r\nroles.use('edit user', '/user/:userID', function (req) {\r\n  if (req.params.userID === req.user.id) return true;\r\n});\r\n```\r\n\r\n  Note that this authorisation strategy will only be used on routes that match `path`.\r\n\r\n  It is equivallent to calling:\r\n\r\n```javascript\r\nvar keys = [];\r\nvar exp = pathToRegexp(path);\r\nroles.use(function (req, act) {\r\n  var match;\r\n  if (act === action && match = exp.exec(req.path)) {\r\n    req = Object.create(req);\r\n    req.params = Object.create(req.params || {});\r\n    keys.forEach(function (key, i) {\r\n      req.params[key.name] = match[i+1];\r\n    });\r\n    return fn(req);\r\n  }\r\n});\r\n```\r\n\r\n### roles.can(action) and roles.is(action)\r\n\r\n  `can` and `is` are synonyms everywhere they appear.\r\n\r\n  You can use these as express route middleware:\r\n\r\n```javascript\r\nvar user = roles;\r\n\r\napp.get('/profile/:id', user.can('edit profile'), function (req, res) {\r\n  req.render('profile-edit', { id: req.params.id });\r\n})\r\napp.get('/admin', user.is('admin'), function (req, res) {\r\n  res.render('admin');\r\n}\r\n```\r\n\r\n### req.user.can(action) and req.user.is(action)\r\n\r\n  `can` and `is` are synonyms everywhere they appear.\r\n\r\n  These functions return `true` or `false` depending on whether the user has access.\r\n\r\n  e.g.\r\n\r\n```javascript\r\napp.get('/', function (req, res) {\r\n  if (req.user.is('admin')) {\r\n    res.render('home/admin');\r\n  } else if (user.can('login')) {\r\n    res.render('home/login');\r\n  } else {\r\n    res.render('home');\r\n  }\r\n})\r\n```\r\n\r\n### user.can(action) and user.is(action)\r\n\r\n  Inside the views of an express application you may use `user.can` and `user.is` which are equivallent to `req.user.can` and `req.user.is`\r\n\r\n  e.g.\r\n\r\n```html\r\n<% if (user.can('impersonate')) { %>\r\n  <button id=\"impersonate\">Impersonate</button>\r\n<% } %>\r\n```\r\n\r\n  **N.B.** not displaying a button doesn't mean someone can't do the thing that the button would do if clicked.  The view is not where your security should go, but it is important for useability that you don't display buttons that will just result in 'access denied' where possible.\r\n\r\n### roles.setFailureHandler(fn(req, res, action))\r\n\r\n  You can (and should) set the failure handler.  This is called whenever a user fails authorisation in route middleware.\r\n\r\n  Defaults to:\r\n\r\n```javascript\r\nuser.setFailureHandler(function (req, res, action){\r\n  res.send(403);\r\n});\r\n```\r\n\r\n  There is no \"next\" by design, to stop you accidentally calling it and allowing someone into a restricted part of your site.  You are passed the action requested which caused them to be denied access.\r\n\r\n  You could using this to redirect the user or render an error page:\r\n\r\n```javascript\r\nuser.setFailureHandler(function (req, res, action){\r\n  var accept = req.headers.accept || '';\r\n  res.status(403);\r\n  if(req.user.isAuthenticated){\r\n    if (~accept.indexOf('html')) {\r\n      res.render('access-denied', {action: action});\r\n    } else {\r\n      res.send('Access Denied - You don\\'t have permission to: ' + action);\r\n    }\r\n  } else {\r\n    res.redirect('/login');\r\n  }\r\n});\r\n```\r\n\r\n## License\r\n\r\n  MIT\r\n  \r\n  If you find it useful, a payment via [gittip](https://www.gittip.com/ForbesLindesay) would be appreciated.",
  "readmeFilename": "readme.md",
  "_id": "connect-roles@2.1.0",
  "_from": "connect-roles@~2.1.0"
}
